<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>College Team Analytics – CFBD Live</title>
<style>
  :root{
    --bg:#0b111a;--panel:#0f1621;--muted:#95a3b8;--text:#e6edf3;
    --border:#1e2633;--brand:#4aa9ff;--accent:#9b59ff;--good:#2dd4bf;--bad:#f43f5e;
    --radius:14px
  }
  *{box-sizing:border-box}
  body{margin:0;background:radial-gradient(1200px 600px at 20% -10%,#0b1220,transparent),radial-gradient(900px 500px at 100% 0%,#071422,transparent),var(--bg);color:var(--text);font:14px/1.45 Inter,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
  .wrap{max-width:1250px;margin:28px auto;padding:0 16px}
  .row{display:flex;flex-wrap:wrap;gap:12px;align-items:center}
  h1{font-size:26px;margin:0 0 10px}
  .pill{background:#0b1420;border:1px solid var(--border);padding:4px 10px;border-radius:999px;color:#cbd5e1;font-size:12px}
  select,input,button{appearance:none;background:var(--panel);border:1px solid var(--border);color:var(--text);border-radius:10px;padding:10px 12px}
  button{cursor:pointer}
  .card{background:linear-gradient(180deg,rgba(255,255,255,.02),transparent),var(--panel);border:1px solid var(--border);border-radius:var(--radius);padding:16px}
  .grid{display:grid;gap:16px}
  .grid-2{grid-template-columns:1fr 1fr}
  @media (max-width:1000px){.grid-2{grid-template-columns:1fr}}
  .error{background:#2a1320;border:1px solid #5c1e34;color:#ffd1da;padding:10px 12px;border-radius:10px;margin-bottom:12px;white-space:pre-wrap;display:none}
  .info{background:#112333;border:1px solid #214a5e;color:#c9f1ff;padding:10px 12px;border-radius:10px;margin-top:8px}
  .svgbox{width:100%; height:360px; border:1px solid var(--border); border-radius:12px; background:rgba(255,255,255,.01); display:flex; align-items:center; justify-content:center}
  .legend{display:flex;gap:12px;align-items:center;font-size:12px;color:#a9b4c2;margin-top:8px}
  .dot{width:10px;height:10px;border-radius:50%}
  .dot.a{background:var(--brand)}.dot.b{background:var(--accent)}
  .statgrid{display:grid;gap:10px;grid-template-columns:repeat(4,minmax(180px,1fr))}
  @media (max-width:1100px){.statgrid{grid-template-columns:repeat(2,minmax(180px,1fr))}}
  .stat{border:1px solid var(--border);border-radius:12px;padding:10px;background:rgba(255,255,255,.02);min-height:74px}
  .stat label{font-size:12px;color:var(--muted)}
  .stat .v{font-weight:700;font-size:18px;margin-top:4px}
  .fade{opacity:.6}
  table{width:100%;border-collapse:collapse}
  th,td{border-bottom:1px solid var(--border);padding:8px 10px;text-align:left}
  th{color:#c8d2e0;font-weight:600}
  .toolbar{display:flex;gap:10px;align-items:flex-end;flex-wrap:wrap}
  .toolbar > div{display:flex;flex-direction:column;gap:6px}
  .grow{flex:1}
</style>
</head>
<body>
<div class="wrap">
  <h1>Team Analytics <span class="pill">CFBD Live</span> <span class="pill">Compare & Explore</span></h1>

  <div id="errorBox" class="error"></div>

  <div class="card">
    <div class="toolbar">
      <div class="grow">
        <label>CFBD API Key</label>
        <input id="apiKey" placeholder="Paste your CFBD key (stored locally)" />
      </div>
      <div>
        <label>Season</label>
        <select id="year"></select>
      </div>
      <div>
        <label>Team A</label>
        <select id="teamA"></select>
      </div>
      <div>
        <label>Team B (compare)</label>
        <select id="teamB"></select>
      </div>
      <div>
        <button id="reload">Reload from CFBD</button>
      </div>
    </div>
    <div class="info">Tip: pick any two teams to compare. Advanced metrics auto-fill when CFBD provides them; if not, we still compute what we can from season totals.</div>
  </div>

  <div class="grid grid-2" style="margin-top:16px">
    <div class="card">
      <h3>Offensive Profile (Spider)</h3>
      <div id="offRadar" class="svgbox"></div>
      <div class="legend"><span class="dot a"></span>Team A &nbsp;&nbsp;<span class="dot b"></span>Team B</div>
    </div>
    <div class="card">
      <h3>Defensive Profile (Spider)</h3>
      <div id="defRadar" class="svgbox"></div>
      <div class="legend"><span class="dot a"></span>Team A &nbsp;&nbsp;<span class="dot b"></span>Team B</div>
    </div>
  </div>

  <div class="grid grid-2" style="margin-top:16px">
    <div class="card">
      <h3>Head-to-Head Efficiency (Bars)</h3>
      <div id="barsH2H" class="svgbox"></div>
      <div class="legend"><span class="dot a"></span>Team A &nbsp;&nbsp;<span class="dot b"></span>Team B</div>
    </div>
    <div class="card">
      <h3>Pace & Play Mix (Bars)</h3>
      <div id="barsPace" class="svgbox"></div>
      <div class="legend"><span class="dot a"></span>Team A &nbsp;&nbsp;<span class="dot b"></span>Team B</div>
    </div>
  </div>

  <div class="card" style="margin-top:16px">
    <h3>Snapshot – Key Stats</h3>
    <div id="snap" class="statgrid"></div>
    <div class="info">Gray entries mean a value couldn’t be computed or wasn’t returned by CFBD for that team/year.</div>
  </div>

  <div class="card" style="margin-top:16px">
    <h3>Full Stat Table</h3>
    <table id="statTable">
      <thead>
        <tr><th>Stat</th><th>Team A</th><th>Team B</th><th>How it’s calculated</th></tr>
      </thead>
      <tbody></tbody>
    </table>
  </div>
</div>

<script>
(function(){
  // ----------- UI helpers -----------
  const $ = id => document.getElementById(id);
  const err = $("errorBox");
  const showErr = (msg) => { err.textContent = msg; err.style.display = "block"; };
  const clearErr = () => { err.style.display = "none"; err.textContent = ""; };

  // ----------- CFBD API ----------------
  const CFBD = {
    base: "https://api.collegefootballdata.com",
    key: "",
    headers(){ return { "Authorization":"Bearer "+CFBD.key }; },
    async json(path, params={}){
      const url = new URL(CFBD.base + path);
      Object.entries(params).forEach(([k,v])=> (v!==undefined && v!==null) && url.searchParams.append(k, v));
      const res = await fetch(url, { headers: CFBD.headers() });
      if(!res.ok) throw new Error(`CFBD ${res.status}: ${await res.text()}`);
      return res.json();
    },
    // FBS teams list
    listTeams(year){ return CFBD.json("/teams/fbs",{ year }); },
    // Season aggregate “simple” stats (rushing, passing, downs, penalties, turnovers, etc.)
    seasonStats(year, team){ return CFBD.json("/stats/season", { year, team }); },
    // Advanced: Points per Play (PPA) offense/defense (team aggregate)
    ppaTeam(year, team){ return CFBD.json("/metrics/ppa/teams", { year, team, excludeGarbageTime: true }); },
    // Advanced: Success Rate (team)
    successTeam(year, team){ return CFBD.json("/metrics/success/teams", { year, team, excludeGarbageTime: true }); },
    // Advanced: Explosiveness (team)
    explosiveTeam(year, team){ return CFBD.json("/metrics/explosiveness/teams", { year, team, excludeGarbageTime: true }); },
    // FPI / SP+ equivalents aren’t in CFBD; leaving a hook:
    fpiTeam(year, team){ return Promise.resolve(null); }
  };

  // ----------- Years -----------
  const thisYear = new Date().getFullYear();
  const years = Array.from({length: 25}, (_,i)=> thisYear - i); // last 25 seasons
  $("year").innerHTML = years.map(y=>`<option value="${y}">${y}</option>`).join("");
  $("year").value = thisYear;

  // Persist API key locally
  $("apiKey").value = localStorage.getItem("cfbd_api_key") || "";
  const saveKey = () => { localStorage.setItem("cfbd_api_key", $("apiKey").value.trim()); };
  $("apiKey").addEventListener("change", saveKey);

  // Data cache (per year)
  const CACHE = {}; // { [year]: { teams:[{school,...}], teamData: { [team]: mergedObj } } }

  // ----------- Formatting helpers -----------
  const fmt = (n,d=3) => (n==null||isNaN(n)) ? "—" : Number(n).toFixed(d);
  const pct = n => (n==null||isNaN(n)) ? "—" : (n*100).toFixed(1)+"%";
  const secToClock = s => (s==null||!isFinite(s)) ? "—" : new Date(s*1000).toISOString().substr(11,8);

  // Pull safe numeric
  const num = v => (typeof v === "number" && isFinite(v)) ? v : null;

  // Build our canonical data shape from CFBD responses
  async function loadTeam(year, teamName){
    const y = String(year);
    if(!CACHE[y]) CACHE[y] = { teams: [], teamData: {} };
    if(CACHE[y].teamData[teamName]) return CACHE[y].teamData[teamName];

    // Fetch in parallel; tolerate failures
    const tasks = [
      CFBD.seasonStats(year, teamName).catch(()=>[]),
      CFBD.ppaTeam(year, teamName).catch(()=>[]),
      CFBD.successTeam(year, teamName).catch(()=>[]),
      CFBD.explosiveTeam(year, teamName).catch(()=>[]),
      CFBD.fpiTeam(year, teamName).catch(()=>null),
    ];
    const [season, ppa, succ, expl, fpi] = await Promise.all(tasks);

    // CFBD /stats/season returns an array; we’ll merge interesting fields
    // We sum “offense” rows to get totals; many fields are already totals.
    const sRow = Array.isArray(season) ? season.find(r=>r.team === teamName) || season[0] : null;

    // Build “simple”
    const simple = {
      games: num(sRow?.games),
      passYds: num(sRow?.passingYards),
      rushYds: num(sRow?.rushingYards),
      passAtt: num(sRow?.passingAttempts),
      rushAtt: num(sRow?.rushingAttempts),
      oppPassYds: num(sRow?.opponentPassingYards),
      oppRushYds: num(sRow?.opponentRushingYards),
      firstDowns: num(sRow?.firstDowns),
      oppFirstDowns: num(sRow?.opponentFirstDowns),
      turnovers: num(sRow?.turnovers),
      takeaways: num(sRow?.takeaways),
      penalties: num(sRow?.penalties),
      penaltyYds: num(sRow?.penaltyYards),
      timePossSeconds: num(sRow?.timeOfPossession), // CFBD returns seconds
      totalYds: num(sRow?.totalYards),
      oppTotalYds: num(sRow?.opponentTotalYards),
      plays: num(sRow?.plays),
      oppPlays: num(sRow?.opponentPlays)
    };

    // Advanced merges (normalize common shape)
    const adv = { offense:{}, defense:{} };

    // PPA
    const ppaRow = Array.isArray(ppa) ? ppa.find(r=>r.team === teamName) : null;
    if(ppaRow){
      adv.offense.ppa = num(ppaRow?.offense?.overall?.ppa);
      adv.defense.ppa = num(ppaRow?.defense?.overall?.ppa);
      adv.offense.plays = num(ppaRow?.offense?.overall?.plays) ?? simple.plays;
      adv.defense.plays = num(ppaRow?.defense?.overall?.plays) ?? simple.oppPlays;
    }

    // Success Rate
    const sRow2 = Array.isArray(succ) ? succ.find(r=>r.team === teamName) : null;
    if(sRow2){
      adv.offense.successRate = num(sRow2?.offense?.overall?.successRate);
      adv.defense.successRate = num(sRow2?.defense?.overall?.successRate);
    }

    // Explosiveness
    const eRow = Array.isArray(expl) ? expl.find(r=>r.team === teamName) : null;
    if(eRow){
      adv.offense.explosiveness = num(eRow?.offense?.overall?.explosiveness);
      adv.defense.explosiveness = num(eRow?.defense?.overall?.explosiveness);
    }

    const out = {
      team: teamName,
      year,
      simple: {
        overall__games: simple.games,
        overall__netpassingyards: simple.passYds,
        overall__rushingyards: simple.rushYds,
        overall__passattempts: simple.passAtt,
        overall__rushattempts: simple.rushAtt,
        overall__netpassingyardsopponent: simple.oppPassYds,
        overall__rushingyardsopponent: simple.oppRushYds,
        overall__firstdowns: simple.firstDowns,
        overall__firstdownsopponent: simple.oppFirstDowns,
        overall__turnovers: simple.turnovers,
        overall__turnoversopponent: simple.takeaways,
        overall__penalties: simple.penalties,
        overall__penaltyyards: simple.penaltyYds,
        overall__possessiontime: simple.timePossSeconds,
        overall__totalyards: simple.totalYds,
        overall__totalyardsopponent: simple.oppTotalYds,
        overall__plays: simple.plays,
        overall__playsopponent: simple.oppPlays
      },
      advanced: adv,
      fpi: fpi || null
    };

    CACHE[y].teamData[teamName] = out;
    return out;
  }

  async function loadTeamsForYear(year){
    clearErr();
    const y = String(year);
    if(CACHE[y]?.teams?.length) return CACHE[y].teams;

    const list = await CFBD.listTeams(year);
    // CFBD returns [{school, conference, logos, ...}]
    CACHE[y] = CACHE[y] || { teams: [], teamData: {} };
    CACHE[y].teams = list.map(t=>({ school: t.school, conference: t.conference || "" }))
                         .sort((a,b)=> a.school.localeCompare(b.school));
    return CACHE[y].teams;
  }

  // ----------- Charts (same as before) -----------
  function el(name, attrs={}, children=[]){
    const n=document.createElementNS("http://www.w3.org/2000/svg",name);
    Object.entries(attrs).forEach(([k,v])=> n.setAttribute(k,v));
    children.forEach(c=> n.appendChild(c));
    return n;
  }
  function clear(node){ while(node.firstChild) node.removeChild(node.firstChild); }
  function barChartDual(node, labels, A, B){
    clear(node);
    const w=node.clientWidth||640, h=node.clientHeight||360, pad={l:80,r:20,t:24,b:44};
    const svg=el("svg",{width:w,height:h,viewBox:`0 0 ${w} ${h}`});
    const gw=w-pad.l-pad.r, gh=h-pad.t-pad.b;
    const max=Math.max(0.001, ...A.map(v=>Math.abs(v||0)), ...B.map(v=>Math.abs(v||0)));
    svg.appendChild(el("rect",{x:pad.l,y:pad.t,width:gw,height:gh,fill:"none",stroke:"#223045"}));
    const band=gw/labels.length;
    const bw=band*0.36;
    labels.forEach((lab,i)=>{
      const x=pad.l+band*i;
      const vA=A[i]??0, vB=B[i]??0;
      const hA=(Math.abs(vA)/max)*(gh*0.9), hB=(Math.abs(vB)/max)*(gh*0.9);
      const yA=pad.t+gh-hA, yB=pad.t+gh-hB;
      svg.appendChild(el("rect",{x:x+band*0.5-bw-3,y:yA,width:bw,height:hA,fill:"var(--brand)"}));
      svg.appendChild(el("rect",{x:x+band*0.5+3,y:yB,width:bw,height:hB,fill:"var(--accent)"}));
      svg.appendChild(el("text",{x:x+band*0.5,y:pad.t+gh+16,fill:"#a9b4c2","text-anchor":"middle","font-size":"11"},[document.createTextNode(lab)]));
    });
    node.appendChild(svg);
  }
  function radarDual(node, labels, valsA, valsB, colorA="var(--brand)", colorB="var(--accent)"){
    clear(node);
    const w=node.clientWidth||640,h=node.clientHeight||360,cx=w/2,cy=h/2,r=Math.min(w,h)/2-28,rings=4;
    const svg=el("svg",{width:w,height:h,viewBox:`0 0 ${w} ${h}`});
    for(let k=1;k<=rings;k++){
      const rr=(r/rings)*k, pts=[];
      for(let i=0;i<labels.length;i++){
        const a=(Math.PI*2/labels.length)*i - Math.PI/2;
        pts.push(`${cx+rr*Math.cos(a)},${cy+rr*Math.sin(a)}`);
      }
      svg.appendChild(el("polygon",{points:pts.join(" "),fill:"none",stroke:"#223045"}));
    }
    for(let i=0;i<labels.length;i++){
      const a=(Math.PI*2/labels.length)*i - Math.PI/2;
      svg.appendChild(el("line",{x1:cx,y1:cy,x2:cx+r*Math.cos(a),y2:cy+r*Math.sin(a),stroke:"#223045"}));
      const lx=cx+(r+14)*Math.cos(a), ly=cy+(r+14)*Math.sin(a);
      svg.appendChild(el("text",{x:lx,y:ly,fill:"#a9b4c2","font-size":"11","text-anchor": Math.cos(a)>0.1?"start":(Math.cos(a)<-0.1?"end":"middle"),"dominant-baseline":"middle"},[document.createTextNode(labels[i])]));
    }
    function poly(vals,color){
      const pts=vals.map((v,i)=>{ const a=(Math.PI*2/vals.length)*i - Math.PI/2; const rr=r*Math.max(0,Math.min(1,v)); return `${cx+rr*Math.cos(a)},${cy+rr*Math.sin(a)}`; }).join(" ");
      svg.appendChild(el("polygon",{points:pts,fill:color+"30",stroke:color,"stroke-width":"2"}));
    }
    poly(valsA,colorA); poly(valsB,colorB);
    node.appendChild(svg);
  }

  // ----------- Metrics & rendering -----------
  function get(simple, key){ return num(simple?.[key]) }
  function totalYards(s){ return get(s,"overall__totalyards") ?? ((get(s,"overall__netpassingyards")||0)+(get(s,"overall__rushingyards")||0)); }
  function totalYardsOpp(s){ return get(s,"overall__totalyardsopponent") ?? ((get(s,"overall__netpassingyardsopponent")||0)+(get(s,"overall__rushingyardsopponent")||0)); }
  function playsOff(t){ return num(t?.advanced?.offense?.plays) ?? get(t.simple,"overall__plays") ?? ((get(t.simple,"overall__passattempts")||0)+(get(t.simple,"overall__rushattempts")||0)); }
  function playsDef(t){ return num(t?.advanced?.defense?.plays) ?? get(t.simple,"overall__playsopponent") ?? ((get(t.simple,"overall__passattemptsopponent")||0)+(get(t.simple,"overall__rushattemptsopponent")||0)); }
  const perGame = (v,g) => (v!=null && g>0) ? v/g : null;

  const METRICS = [
    ["Points per Play (Offense)", t => t?.advanced?.offense?.ppa ?? null, "From CFBD PPA team metrics."],
    ["Success Rate (Offense)", t => t?.advanced?.offense?.successRate ?? null, "Share of plays keeping the drive on schedule."],
    ["Explosiveness (Offense)", t => t?.advanced?.offense?.explosiveness ?? null, "How big the gains are when a play hits."],
    ["Yards per Play (Offense)", t => { const ty=totalYards(t.simple), p=playsOff(t); return (ty!=null&&p)? ty/p : null }, "Total yards divided by offensive plays."],

    ["Points per Play Allowed (Defense)", t => t?.advanced?.defense?.ppa ?? null, "Points allowed per play."],
    ["Success Rate Allowed (Defense)", t => t?.advanced?.defense?.successRate ?? null, "Opponents’ on-schedule rate."],
    ["Explosiveness Allowed (Defense)", t => t?.advanced?.defense?.explosiveness ?? null, "Opponents’ gain size on hits."],
    ["Yards per Play Allowed (Defense)", t => { const ty=totalYardsOpp(t.simple), p=playsDef(t); return (ty!=null&&p)? ty/p : null }, "Opponents’ total yards divided by defensive plays."],

    ["Total Yards per Game", t => perGame(totalYards(t.simple), t?.simple?.overall__games ?? 0), "Team total yards divided by games."],
    ["Opponent Yards per Game", t => perGame(totalYardsOpp(t.simple), t?.simple?.overall__games ?? 0), "Opponents’ total yards divided by games."],
    ["Pass Rate (share of plays)", t => { const pa=get(t.simple,"overall__passattempts"), ra=get(t.simple,"overall__rushattempts"); return (pa!=null&&ra!=null&&pa+ra>0) ? pa/(pa+ra) : null; }, "Pass attempts / (pass + rush attempts)."],
    ["Rush Rate (share of plays)", t => { const pa=get(t.simple,"overall__passattempts"), ra=get(t.simple,"overall__rushattempts"); return (pa!=null&&ra!=null&&pa+ra>0) ? ra/(pa+ra) : null; }, "Rush attempts / (pass + rush attempts)."],
    ["Plays per Game (Offense)", t => perGame(playsOff(t), t?.simple?.overall__games ?? 0), "Offensive plays divided by games."],
    ["Time of Possession per Game", t => perGame(get(t.simple,"overall__possessiontime"), t?.simple?.overall__games ?? 0), "Seconds with the ball per game (clock)."],
    ["First Downs per Game", t => perGame(get(t.simple,"overall__firstdowns"), t?.simple?.overall__games ?? 0), "First downs divided by games."],
    ["First Downs Allowed per Game", t => perGame(get(t.simple,"overall__firstdownsopponent"), t?.simple?.overall__games ?? 0), "Opponents’ first downs per game."],
    ["Turnover Margin per Game", t => { const to=get(t.simple,"overall__turnovers"); const ta=get(t.simple,"overall__turnoversopponent"); const g=t?.simple?.overall__games ?? 0; return (to!=null&&ta!=null&&g>0)? (ta-to)/g : null; }, "(Takeaways − giveaways) per game."],
    ["Penalties per Game", t => perGame(get(t.simple,"overall__penalties"), t?.simple?.overall__games ?? 0), "Flags against the team per game."],
    ["Penalty Yards per Game", t => perGame(get(t.simple,"overall__penaltyyards"), t?.simple?.overall__games ?? 0), "Penalty yards per game."]
  ];

  // Normalize maxima for radar scaling (per year, across loaded teams so far)
  function computeMaxima(dataset){
    return dataset.reduce((m,t)=>{
      const off=t?.advanced?.offense||{}, def=t?.advanced?.defense||{};
      const ypp = (()=>{ const ty=totalYards(t.simple), p=playsOff(t); return (ty!=null&&p)? ty/p : 0; })();
      const yppa=(()=>{ const ty=totalYardsOpp(t.simple), p=playsDef(t); return (ty!=null&&p)? ty/p : 0; })();
      m.opp = Math.max(m.opp, off.ppa??0);
      m.osr = Math.max(m.osr, off.successRate??0);
      m.oex = Math.max(m.oex, off.explosiveness??0);
      m.oyp = Math.max(m.oyp, ypp||0);
      m.dpp = Math.max(m.dpp, def.ppa??0);
      m.dsr = Math.max(m.dsr, def.successRate??0);
      m.dex = Math.max(m.dex, def.explosiveness??0);
      m.dyp = Math.max(m.dyp, yppa||0);
      return m;
    },{opp:0,osr:0,oex:0,oyp:0,dpp:0,dsr:0,dex:0,dyp:0});
  }
  const norm = (v,max) => Math.min(1,(v||0)/(max||1));

  // ----- Populate team selects & render -----
  const sYear = $("year"), sA = $("teamA"), sB = $("teamB"), btnReload = $("reload");

  async function populateTeams(){
    try{
      clearErr();
      CFBD.key = ($("apiKey").value || "").trim();
      if(!CFBD.key){ showErr("Please paste your CFBD API key first."); return; }
      const year = sYear.value;
      const teams = await loadTeamsForYear(year);
      const opts = teams.map(t=>`<option value="${t.school}">${t.school}</option>`).join("");
      sA.innerHTML = opts; sB.innerHTML = opts;
      if(teams.length){ sA.value = teams[0].school; sB.value = teams[1]?.school || teams[0].school; }
      await render();
    }catch(e){ showErr(e.message); }
  }

  async function render(){
    try{
      clearErr();
      CFBD.key = ($("apiKey").value || "").trim();
      if(!CFBD.key){ showErr("Please paste your CFBD API key first."); return; }
      const year = sYear.value;
      const teamA = sA.value, teamB = sB.value;

      // Load both teams (and keep a growing pool to scale the radar more meaningfully)
      const [A,B] = await Promise.all([loadTeam(year, teamA), loadTeam(year, teamB)]);
      // Include every team we've loaded this session for maxima
      const loaded = Object.values(CACHE[String(year)].teamData);
      const MAX = computeMaxima(loaded);

      // Spiders
      const calcYPP = t => { const ty=totalYards(t.simple), p=playsOff(t); return (ty!=null&&p)? ty/p : 0; };
      const calcYPPD= t => { const ty=totalYardsOpp(t.simple), p=playsDef(t); return (ty!=null&&p)? ty/p : 0; };

      const AoffRaw = [A?.advanced?.offense?.ppa, A?.advanced?.offense?.successRate, A?.advanced?.offense?.explosiveness, calcYPP(A)];
      const BoffRaw = [B?.advanced?.offense?.ppa, B?.advanced?.offense?.successRate, B?.advanced?.offense?.explosiveness, calcYPP(B)];
      const Aoff = [norm(AoffRaw[0],MAX.opp), norm(AoffRaw[1],MAX.osr), norm(AoffRaw[2],MAX.oex), norm(AoffRaw[3],MAX.oyp)];
      const Boff = [norm(BoffRaw[0],MAX.opp), norm(BoffRaw[1],MAX.osr), norm(BoffRaw[2],MAX.oex), norm(BoffRaw[3],MAX.oyp)];
      radarDual($("offRadar"), ["Points/Play","Success","Explosiveness","Yards/Play"], Aoff, Boff);

      const AdefRaw = [A?.advanced?.defense?.ppa, A?.advanced?.defense?.successRate, A?.advanced?.defense?.explosiveness, calcYPPD(A)];
      const BdefRaw = [B?.advanced?.defense?.ppa, B?.advanced?.defense?.successRate, B?.advanced?.defense?.explosiveness, calcYPPD(B)];
      const Adef = [norm(AdefRaw[0],MAX.dpp), norm(AdefRaw[1],MAX.dsr), norm(AdefRaw[2],MAX.dex), norm(AdefRaw[3],MAX.dyp)];
      const Bdef = [norm(BdefRaw[0],MAX.dpp), norm(BdefRaw[1],MAX.dsr), norm(BdefRaw[2],MAX.dex), norm(BdefRaw[3],MAX.dyp)];
      radarDual($("defRadar"), ["Pts/Play Allowed","Success Allowed","Explosive Allowed","Yds/Play Allowed"], Adef, Bdef);

      // Head-to-Head bars
      const labels1 = ["Pts/Play (Off)","Pts/Play Allowed","Success (Off)","Success Allowed","Yds/Play (Off)","Yds/Play Allowed"];
      barChartDual($("barsH2H"), labels1,
        [AoffRaw[0]||0, AdefRaw[0]||0, AoffRaw[1]||0, AdefRaw[1]||0, AoffRaw[3]||0, AdefRaw[3]||0],
        [BoffRaw[0]||0, BdefRaw[0]||0, BoffRaw[1]||0, BdefRaw[1]||0, BoffRaw[3]||0, BdefRaw[3]||0]
      );

      // Pace & Mix bars
      const Ap = playsOff(A)||0, Bp=playsOff(B)||0;
      const Apass=get(A.simple,"overall__passattempts"), Arush=get(A.simple,"overall__rushattempts");
      const Bpass=get(B.simple,"overall__passattempts"), Brush=get(B.simple,"overall__rushattempts");
      const Ag=get(A.simple,"overall__games")||0, Bg=get(B.simple,"overall__games")||0;
      const Atempo=Ag?Ap/Ag:0, Btempo=Bg?Bp/Bg:0;
      const ApassShare=(Apass!=null&&Arush!=null&&(Apass+Arush)>0)?Apass/(Apass+Arush):0;
      const BpassShare=(Bpass!=null&&Brush!=null&&(Bpass+Brush)>0)?Bpass/(Bpass+Brush):0;
      barChartDual($("barsPace"), ["Plays/Game","Pass Rate"], [Atempo,ApassShare],[Btempo,BpassShare]);

      // Snapshot (top cards)
      const snap = $("snap"); snap.innerHTML="";
      const topSnap = ["Points per Play (Offense)","Yards per Play (Offense)","Success Rate (Offense)","Explosiveness (Offense)","Points per Play Allowed (Defense)","Yards per Play Allowed (Defense)","Success Rate Allowed (Defense)","Explosiveness Allowed (Defense)","Plays per Game (Offense)","Pass Rate (share of plays)","Rush Rate (share of plays)","Total Yards per Game","Opponent Yards per Game","First Downs per Game","Turnover Margin per Game","Time of Possession per Game"];
      topSnap.forEach(name=>{
        const m = METRICS.find(x=>x[0]===name);
        const va = m? m[1](A) : null;
        const vtxt = name.includes("Rate") || name.includes("Share") ? pct(va) : (name.includes("Time of Possession") ? secToClock(va) : fmt(va, name.includes("Yards")?2:3));
        const div=document.createElement("div"); div.className="stat"+(va==null?" fade":"");
        div.innerHTML=`<label>${name}</label><div class="v">${vtxt}</div>`;
        snap.appendChild(div);
      });

      // Full table
      const tbody = $("statTable").querySelector("tbody");
      tbody.innerHTML="";
      METRICS.forEach(([name,getter,desc])=>{
        const Av = getter(A), Bv=getter(B);
        const isPct = name.toLowerCase().includes("rate") || name.toLowerCase().includes("share");
        const isClock = name.includes("Time of Possession");
        const Avs = isPct ? pct(Av) : (isClock ? secToClock(Av) : fmt(Av, name.includes("Yards")?2:3));
        const Bvs = isPct ? pct(Bv) : (isClock ? secToClock(Bv) : fmt(Bv, name.includes("Yards")?2:3));
        const tr=document.createElement("tr");
        tr.innerHTML=`<td>${name}</td><td class="${Av==null?'fade':''}">${Avs}</td><td class="${Bv==null?'fade':''}">${Bvs}</td><td class="fade">${desc}</td>`;
        tbody.appendChild(tr);
      });
    }catch(e){ showErr(e.message); }
  }

  // Wire up events
  btnReload.addEventListener("click", async ()=>{ CACHE[String(sYear.value)] = { teams: [], teamData: {} }; await populateTeams(); });
  sYear.addEventListener("change", populateTeams);
  sA.addEventListener("change", render);
  sB.addEventListener("change", render);

  // First load
  populateTeams();
})();
</script>
</body>
</html> 